1. 缓存穿透
现象：有大量的无效请求，在缓存查询不到，直接到数据库中查询  
解决方案：
 - 只要从库中没有查到，就设置一个键到redis，设置一个过期时间，这样下次再有无效的key直接读取缓存的数据直接返回
 - 使用布隆过滤器来对是否命中作处理
2. 缓存击穿
现象：某个key访问非场频繁，此时key失效了，导致大量的并发打到数据库  
解决方案：
 - 缓存数据基本不更新，设置永久有效
 - 缓存数据少量更新，添加锁让少量的请求请求数据库并且重新构建缓存，其余线程在锁释放后可以访问
 - 缓存数据更新频繁，起一个定时线程检查线程的过期时间，如果快过期，重新设置时间或者重新构建新的缓存信息
 
3. 缓存雪崩  
现象：将缓存重启之后或者同时失效，导致在高峰期缓存都没有命中，直接把所有请求都请求到了数据库，导致数据库也挂了  
解决方案：  
 - 事前：将redis设置为高可用，主从+哨兵，redis cluster，在原来过期时间基础上加上一个随机时间戳，防止同时失效   
 - 事中：使用java的ehcache缓存，hystrix限流、降级
 - 事后：redis持久化
 
4. 布隆过滤器
 - 使用多种hash算法算出一个字符串的hash值，将bitset集合中的值设置为true
 - 每种hash算法计算时，都是将传入的字符串拆分成字符，进行hash运算

5. 为什么redis单线程效率这么高
 - 纯内存操作
 - C语言实现
 - 非阻塞IO，如果发现线程被占用会直接返回
 - 内部的数据结构比较好
 
6. 主从同步  
全量同步：当从节点第一次连接主节点触发全量同步
 - 从节点连接主节点时，发送sync命令
 - 主节点收到命令之后，生成rdb文件并且使用缓存区记录此后执行的所有写命令
 - 主节点rdb文件生成完毕之后，向从节点发送rdb文件，发送期间继续记录写命令
 - 从节点收到快照文件之后，放弃所有的旧数据，载入收到的快照
 - 主节点发送快照rdb文件之后，开始发送缓冲区的写命令
 - 从节点完成对快照的载入之后，开始接受命令请求，执行缓冲区的写命令

增量同步：初始化之后正常工作
 - 主节点每执行一个写命令就向从节点发送一个写命令 

7. 哨兵
 - 集群监控：负责监控redis master和redis slave进程是否正常工作
 - 消息通知：如果某个redis实例发生故障，发送报警通知给管理员
 - 故障转移：如果master节点挂掉了，自动转移到slave节点上，有选举机制
 - 配置中心：如果故障转移发生了，通知客户端使用新的服务端地址

8. redis的内存淘汰策略：**内存满了之后处理方案**
 - noeviction:当内存超过限制返回错误
 - allkeys-lru:尝试回收使用最少的键
 - volatile-lru:尝试回收使用最少的键，仅限于在过期集合的键
 - allkeys-random:回收随机的键
 - volatile-random:回收随机的键，仅限于在过期集合的键
 - volatile-ttl:回收在过期集合的键，并且优先回收存活时间较短的键
 
9. redis的过期策略：**过期之后处理方案**
 - 定期删除：定时去扫描过期的，如果有过期就删除
 - 惰性删除：命中的时候，如果发现过期了，就删除

9. redis持久化方式  
如果两种都开启，默认使用AOF恢复
 - rdb：
    - 对redis中的数据，周期性进行持久化  
    - 对读影响很小，主线程只需要fork一个子进程，让子进程执行磁盘IO持久化
    - 直接使用RDB重启和恢复，速度比较快
    - 生成快照时，如果太大会导致客户端服务暂停数秒
    - 每隔五分钟生成一次，间隔比较长
 - aof：
    - 日志文件以append-only追加方式写入，没有磁盘寻址开销
    - 日志过大，后台有重写
    - AOF数据比RDB数据大
    - 每隔1秒，通过一个后台线程执行一次fsycn，最多丢失1秒钟数据
