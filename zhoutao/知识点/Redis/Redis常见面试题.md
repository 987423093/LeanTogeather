1. 缓存穿透
现象：有大量的无效请求，在缓存查询不到，直接到数据库中查询  
解决方案：
 - 只要从库中没有查到，就设置一个键到redis，设置一个过期时间，这样下次再有无效的key直接读取缓存的数据直接返回

2. 缓存击穿
现象：某个key访问非场频繁，此时key失效了，导致大量的并发打到数据库  
解决方案：
 - 缓存数据基本不更新，设置永久有效
 - 缓存数据少量更新，添加锁让少量的请求请求数据库并且重新构建缓存，其余线程在锁释放后可以访问
 - 缓存数据更新频繁，起一个定时线程检查线程的过期时间，如果快过期，重新设置时间或者重新构建新的缓存信息
 
3. 缓存雪崩  
现象：将缓存重启之后，导致在高峰期缓存都没有命中，直接把所有请求都请求到了数据库，导致数据库也挂了  
解决方案：  
 - 事前：将redis设置为高可用，主从+哨兵，redis cluster
 - 事中：使用java的ehcache缓存，hystrix限流、降级
 - 事后：redis持久化
 
4. 布隆过滤器
 - 使用多种hash算法算出一个字符串的hash值，将bitset集合中的值设置为true
 - 每种hash算法计算时，都是讲传入的字符串拆分成字符，进行hash运算

5. 为什么redis单线程效率这么高
 - 纯内存操作
 - C语言实现
 - 非阻塞IO，如果发现线程被占用会直接返回
 - 内部的数据结构比较好
 
6. 主从，哨兵
