### InnoDB锁

读读不阻塞，读写阻塞，写写阻塞 
 
InnoDB通过索引时，才会触发行锁，否则都是表锁，行锁基于索引

#### 表锁  
1. 不通过索引的都是表锁
2. 为了允许行锁，表锁共存，还有两种意向锁  
    1. 意向共享锁（IS）：事务打算给数据行加共享锁的时候，必须先获得该表的IS锁
    2. 意向排他锁（IX）：事务打算给数据行加排他锁的时候，必须先获得该表的IX锁

#### 行锁  
读锁：
1. 又称共享锁/S锁
2. 共享，多个客户端可以同时读取同一个资源，不允许其他客户端修改 
  
写锁：
1. 又称排他锁/X锁  
2. 阻塞其他写锁和读锁

***
### 一个事务读，一个事务写：MySQL的隔离级别（行锁的升级，不强制使用读锁/写锁）

MySQL的隔离级别就是锁的事务中不同的应用导致的，只是针对于**读写冲突**的情况

模拟背景介绍：
 - 事务1：写
 - 事务2： 读
 - （默认）读是读取最新的信息
 
事务操作过程分为两步 a.修改 b.提交
1. 锁在事务1修改之后释放  * 加锁 a.修改 * 释放锁 b.提交  
当事务2读到释放锁之后的信息之后，因为事务1还未提交，有异常情况回滚了，导致事务2读到了不存在的数据——脏读
【未提交读】  
如何解决？将释放锁挪到提交之后，就不会有未提交的信息被读取

2. 锁在事务1提交之后释放 * 加锁 a.修改 b.提交 * 释放锁  
当事务2在加锁前读取了信息，并且在释放后读取了信息，发现这两次读取的信息都不一致——重复读  
【提交读】  
如何解决？锁已经挪了，但是读取还是读取最新的，需要对行数据加上版本控制，每次读取都读取当前读事务版本号之前的数据，就可以避免前后数据不一致

3. 锁在事务1提交之后释放 * 加锁 a.插入 b.提交 * 释放锁  
当事务2在加锁前读取了信息，并且在释放后读取了信息，然而版本控制只能控制存在的行（版本信息在行上面），这个时候发现后面读到了被插入的数据——幻读  
【不可重复读】  
如何解决？锁已经挪了，行数据加上版本控制了  
 - 让事务串行，在读的时候就不要有事务在写  
 - 加Gap间隙锁，范围查询时，因为会有还未被插入的行会在后面被查询出来，所以先对未插入的行加入Gap间隙锁，提前加上版本控制，就可以避免（MySQL在不可重复读上已经做了该优化）
 【串行读】
 
 4. 让事务都串行
 
 
### 两个事务同时读写

 当两个事务同时在读和写的时候，除非让事务串行，否则肯定会导致覆盖更新，光靠事务隔离级别已经没有作用，有三种解决方案
 1. 串行
 2. 悲观锁 for update 进行行锁
 3. 乐观锁 加上version
 
 

引用<https://juejin.im/post/6844903645125820424>