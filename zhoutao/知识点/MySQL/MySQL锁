### InnoDB锁

读读不阻塞，读写阻塞，写写阻塞 
 
InnoDB通过索引时，才会触发行锁，否则都是表锁，行锁基于索引

#### 表锁  
1. 不通过索引的都是表锁
2. 为了允许行锁，表锁共存，还有两种意向锁  
    1. 意向共享锁（IS）：事务打算给数据行加共享锁的时候，必须先获得该表的IS锁
    2. 意向排他锁（IX）：事务打算给数据行加排他锁的时候，必须先获得该表的IX锁

#### 行锁  
读锁：
1. 又称共享锁/S锁
2. 共享，多个客户端可以同时读取同一个资源，不允许其他客户端修改 
  
写锁：
1. 又称排他锁/X锁  
2. 阻塞其他写锁和读锁

***
### 一个事务读，一个事务写：MySQL的隔离级别（行锁的升级，不强制使用读锁/写锁）

MySQL的隔离级别就是锁的事务中不同的应用导致的，只是针对于**读写冲突**的情况

MVCC：只有读已提交以及不可重复读才有，分别是语句级和事务级
当前读：for update，每次读都读取最新的
快照都：mvcc，生成快照

模拟背景介绍：
 - 事务A：读
 - 事务B： 写

1. 未提交读  
问题：都是当前读，当B事务修改未提交，A事务读，B事务回滚，导致A事务读到了不应该存在的数据，称为**脏读**

2. 提交读  
解决方案：使用mvcc多版本控制，使用快照读，每次都读已提交的版本号最大的一个。当事务B修改未提交，A事务读，发现B事务未提交，不会读到B事务未提交的数据  
问题：A事务读，B事务修改，B事务提交，A事务读，发现两次读不一致，导致**不可重复读**
 
3. 可重复读  
解决方案：使用mvcc多版本控制，使用快照读，每次读都只读取当前事务的版本，A事务读到的始终是A读事务版本的信息  
问题：普通查询都会使用当前版本不会有问题，使用当前读时，如果是范围查询，修改的信息肯定被读到，但是后面读到了插入的信息，造成了**幻读**  
幻读解决方案：对范围查询的不存在的数据行添加Gap间隙锁，当前读时，锁住这些虚拟行，读完之后再释放锁

4. 串行  
添加锁让事务串行
 
 
### 两个事务同时读写

 当两个事务同时在读和写的时候，除非让事务串行，否则肯定会导致覆盖更新，光靠事务隔离级别已经没有作用，有三种解决方案
 1. 串行
 2. 悲观锁 for update 进行行锁
 3. 乐观锁 加上version
 
 

引用<https://juejin.im/post/6844903645125820424>

***
### 死锁
1. 大事务拆小
2. 降低隔离级别，防止gap间隙锁导致的死锁
3. 添加索引
4. 在同一个事务中，尽可能一次锁定需要的所有资源
