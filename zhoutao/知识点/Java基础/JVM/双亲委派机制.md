#### 类加载器
1. 在jdk中，类加载器分为三种 
    - 根加载器(BootStrapClassLoader)：加载jre/lib/*.jar 所有的class 
    - 扩展类加载器(ExtraClassLoader)：加载jre/lib/extra/*.jar 所有class
    - 应用类加载器：加载当前项目的所有文件
2. 自定义加载器，如果不想走双亲委派可以自己继承ClassLoader实现自定义类加载器，解析String变为Class
3. 一个类是如何从字符串加载成为java类的？
    - Class.forName()方法:将.class文件加载到JVM中，可以选择性执行static代码块
    - ClassLoader.loadClass()方法：将.class文件加载到JVM中，不执行static代码块，只有newInstance的时候才执行static代码块

#### 双亲委派机制解决了什么问题？
答案：防止类的重复加载，保证Java核心包的类不被替换

场景：当我们使用一个类的全限定名去生成一个类对象的时候，假如我们的包是java.lang，类是Object，假如没有双亲委派机制，就会生成两个全限定名一样的类，在调用的时候就不知道用哪一个类
#### 双亲委派机制
1. 什么是双亲委派机制？
一个类要加载，先看当前类的类加载器的父类是否加载过，如果父类加载过，直接返回父类加载过的类，如果父类没有加载过，让父类的父类去加载，一直到顶层假如都没有被加载过，就尝试使用子类去加载，子类如果加载失败，让子类的子类去加载，一直到最后假如没有类可以加载成功就抛出异常
2. 双亲委派的流程
要加载A.class->找到应用程序加载器加载->应用程序加载器委托给扩展类加载器加载->扩展类加载器委托给根加载器加载->根加载器尝试加载，加载成功返回，加载失败由扩展类加载器加载->扩展类加载器尝试加载，加载成功返回，加载失败由应用类加载器加载->应用类加载器加载失败，抛出异常
3. SPI
将要加载的类的全限定名放置在指定位置，然后通过自定义类加载器加载出这个类，否则如果走双亲委派机制，假如当前类的类加载器是根加载器，就无法进行委托，找到子类的加载器加载了。

**双亲委派机制无法通过父类来调用子类的类加载器**