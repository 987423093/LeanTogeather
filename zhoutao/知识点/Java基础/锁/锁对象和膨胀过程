#### Java对象的数据结构
 - 对象头（mark word，klass point）12个字节  
 - 对象的实例数据
 - 对齐子节

#### 对象头的数据结构
 - mark word 8个字节
 - klass point 4个字节（默认指针压缩位4个，否则为8个）指向方法区中的模版类的指针

#### mark word的数据结构
 - 前置知识：
    1.锁状态一共有：无锁001，轻量级锁101，偏向锁00，重量级锁10，gc标志11（表示可以被回收了）  
    2.为什么无锁和轻量级锁是三位的呢？因为有一位偏移标识为，因为用2位只能表示4种情况，如何表示5种情况呢？就加一个位，只有当无锁/轻量级锁才会使用

 - 8个字节一共64位，需要根据不同的锁才能确定每一位的作用  
 
 <img src="../../img/java对象头数据结构.png" width="600" height="300" />  
 
1. 无锁
前25位未被使用，31位存储hash值，后8位（1位未使用，4位分代年龄，1位偏移标志，无锁为0，2位锁标志，无锁为01）  
2. 偏向锁
前54位是线程信息，2位存储时间戳，代表偏向锁的时效性，后8位（1位未使用，4位分代年龄，1位偏移标志，偏向锁为1，2位锁标志，偏向锁为01）  
3. 轻量级锁
前62位为lock_record信息，有hashcode的信息，后2位为锁标志，轻量级锁为00  
4. 重量级锁
前62位为monitor信息，有hashcode的信息，后2位为锁标志，重量级锁为10  
5. gc标志
前62位未被使用，后两位为锁标志，gc标志为11  

锁效率
偏向锁效率 > 轻量级锁效率>重量级锁

注意： 
 - 偏向锁没有hashcode，所以当调用某一个类的hashcode的时候，会自动变成轻量级锁  
 - 如果使用偏向锁？1.让主线程sleep4秒钟 2.使用-XX:BiasedLockingStartupDelay=0  
    - 为什么可以达到这个效果？
因为当项目启动的时候，不光我们的代码，jvm也会运行，里面有很多同步代码，会产生很多轻量级锁，所以让偏向锁在延迟之后，跳过代码运行之后才去有效，避免不必要的锁升级。如果让偏向锁提前或者让我们的代码往后，则就会使用偏向锁

***
#### 锁膨胀
<img src="../img/锁膨胀.png" width="1000" height="500" />

 - 为什么会有锁膨胀：在jdk1.6之前默认是无锁->重量级锁，性能太低。  
 - 性能低的原因：重量级锁会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程时，都需要操作系统从用户态转向内核态，转换需要消耗很长时间

当一个线程进入运行同步方法时,sychronized关键字
1. 判断当前对象的对象头，锁标志是什么? 
2. 锁标识为01，说明为无锁或者偏向锁，需要进一步判断偏移标志？分支3，4
3. 偏移标志为0，标识是无锁状态，跳到7
4. 偏移标志为1，标识为偏向锁状态，判断当前对象头上的thread id是不是当前线程，分支5，6
5. 当前对象头上的mark word记录的线程id 就是当前线程，当前线程获取到偏向锁，执行同步代码（终止）
6. 当前对象头上的mark word记录的线程id 不是当前线程
7. 当前线程尝试修改对象头上的mark word信息 为当前线程id,自旋十次(CAS)
8. 对象头上的mark word记录的线程id成功设置为当前线程id，当前线程获取到偏向锁，执行同步代码（终止）
8. 失败设置对象头上的线程id为当前线程，开始撤销锁
9. 等待原持有偏向锁的线程到达安全点，暂停原持有偏向锁的线程，判断原持有偏向锁的线程状态，分支10，11
10. 如果原持有偏向锁的线程已经过了同步块，释放锁并且唤醒原持有线程，跳到7
11. 如果原持有偏向锁的线程还在进行同步，将对象头的锁升级为轻量级锁
12. 在原持有偏向锁的线程开辟空间lock record，将对象头的mark word信息拷贝到原线程
13. 原持有偏向锁线程获取轻量级锁，轻量级锁上有指向原持有偏向锁线程的指针ptr lock record，此时原线程和当前线程同步执行
14. 原线程：唤醒原持有偏向锁，现在持有轻量级锁的线程，从安全点开始执行，执行完毕等待释放锁，跳到20
15. 当前线程：看到对象头变成轻量级锁也在线程栈中开辟空间lock record，将对象头的mark word信息拷贝到当前线程
16. 尝试将对象头的ptr lock record 指针指向当前线程（CAS），分支17，18
17. 如果将对象头上的ptr lock record指针成功指向当前线程，当前线程持有该对象锁，执行同步代码
18. 如果失败次数打到二十次，锁升级为重量级锁
19. 挂起当前线程，由mutex来判断锁的优先级，执行同步块
20. 释放轻量级锁，判断1.当前线程的对象头上的lock record信息和锁对象头mark word的lock record信息是否一致 2.锁对象头的ptr lock record指针是否指向当前线程，分支21，22
21. 如果上述两个条件都满足，则释放锁
22. 如果有一者不满足，说明对象锁已经变成了重量级锁，改变了锁对象头的数据结构，指向了monitor对象，释放锁并且释放所有被挂起的线程，开始新一轮的锁竞争

 
  